/*
栈 : 先进后出
好比一摞盘子,我们取只能从最上面取盘子,放的话也只能将盘子放在最上面
*/



/*
队列 : 先进先出的线性表
只允许在一端进行插入操作，而在另一端进行删除操作的线性表。 
队列是一种先进先出（First In First Out）的线性表，简称FIFO。 
允许插入的一端称为队尾，允许删除的一端称为队头

优先队列 : 不必遵循队列先进先出的规则
*/



/*
链表: 链表是由一组节点组成的集合,每个节点都使用一个对象的引用指向另一个节点的引用
无法对数据随机访问

head --> start --> null  //链表的形式

{
    element: 'head', 
    next: null
}
上面是初始的链表,   头节点head作为链表的接入点, 链表的最终元素指向null节点

{ 
    element: 'head', 
    next: {
        element: 'start', 
        next: null 
    } 
}
以上是添加一个节点引用后的结果

*****************************************************

双向链表: 从链表的头节点遍历到为节点很简单, 但是反过来从后向前遍历则没那么简单, 我们给节点对象(node)添加一个指向当前节点的前驱的这么一个指向

这样的优势是我们在删除节点时不需要再去查找当前节点的前驱了
{
    element: 'head', 
    next: null,
    previous: null
}
当前节点存在他的上一个节点和下一个节点的指向

*****************************************************
循环链表 : 将头节点的next属性指向头节点本身,也就是说最后一个节点的next属性永远指向头节点,

循环链表 和 单向链表的唯一区别就是 单向链表的最后一个节点的next属性指向null

{
    element: 'head', 
    next: head
}
*/




/* 
    字典 : 一种以键值对形式存储对一种数据结构 类似与js对object
    调用 Object 类的 keys() 方法可以返回传入参数中存储的所有键。
*/




/* 
散列 : 在散列插入、删除、取用数据非常快; 
    对于查找操作来说效率非常低下(比如查找最大值,最小值), 对此我们需要求助于其他的数据结构 二叉查找数

散列函数 : 
    散列化字符类型的键 ; abc --> 我们将abc三个字母对应的ASCLL码的和, ASCLL码的和对数组的长度取余, 取余的结果当作数组的下标，将值存储在以该余数为下标的数组空间里面
    那么散列函数就是以数组的长度对键取余。取余结果就当作数组的下标，将值存储在以该数字为下标的数组空间里。

    散列化整型键 : 用一个随机的9位数来最为键 然后将成绩拼接在后面。 那么散列函数就是以数组的长度对键取余。取余结果就当作数组的下标，将值存储在以该数字为下标的数组空间里。

发生碰撞时如何解决 : 
    开链法: 
        利用二维数组进行处理。比如说有两个需要存储的数据, 经过算法处理后的结果都是2, 那么就以为这这两个数据都需要存入到数组下标为2的位置。因此就发生了碰撞(一个下标对应的位置只能存一个)。
        所以我们可以利用二维数组, 那么下标2对应的的位置是一个数组的化，就可以解决同一位置存入多个数据的问题。 [ [],['a','b'].[] ]

    线性探测法: (开放寻址散列),发生碰撞时,线性探测法会检查散列表的下个位置是否为空,若为空则将数据存入该位置,否则继续检查下一个

    什么时候使用线性探测法，什么时候使用开链法呢？
        如果数组的大小是待存储数据的个数是1.5倍，那么使用开链法，如果数组的大小是待存储的数据的2倍及2倍以上时，那么使用线性探测法。
*/




/* 
集合 : 集合(set)是一种包含不同元素的数据结构。(成员的存在是无序的，并且不允许存在相同的成员)

定义 : 
    不包含任何成员的集合称为空集，全集则是包含一切可能成员的集合。
    如果两个集合的成员完全相同，则称两个集合相等。
    如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一集合的子集。

操作 :
    并集 -- 将两个集合中的成员进行合并，得到一个新集合。
    交集 -- 两个集合中共同存在的成员组成一个新的集合。
    补集 -- 属于一个集合而不属于另一个集合的成员组成的集合。
*/



/*
二叉树和二叉查找树
    树是一种非线性的数据结构,以分层的方式存储数据。 常用来存储具有层级关系的数据(比如系统文件)

二叉树上进行查找非常快(而在链表上查找则不是这样)
二叉树添加或删除元素 也非常快(而对数组执行添加或删除操作则不是这样)

什么是树；
    树是由一组以 边 连接的节点组成 (用来连接各个节点之间的线叫做边线)

二叉查找树: 二叉查找树是一种 特殊的二叉树，通过与父节点比较后相对较小的值保存在左节点中，较大的值保存在右节点中(所以二叉查找树确定子节点非常重要)

键: 每个节点都有一个与之相关的值，该值有时被称为键。
路径: 从一个节点到另一个节点的这一组边称为路径    
遍历: 以某种特定顺序 访问树中所有的节点称为树的遍历
树的层数就是树的深度

实现一个二叉查找树：

一个节点{
    data:'当前节点保存的数据',
    left:'当前节点的左子节点',
    right:'当前节点的右子节点',
}

树节点{
    data:10,
    left:{data:8, left:null, right:null},
    right:{{data:12, left:null, right:null}},
}


遍历二叉查找树:
    中序 : 按照节点上的键值，以升序访问 二叉树（BST） 上的所有节点  --> 可以使用递归实现(顺序为 左子树---根节点---右子树)
    先序 : 先访问根节点，然后以同样方式访问左子树和右子树
    后序 : 先访问叶子节点，从左子树到右子树，再到根节点。
*/



function Node(data, left, right) {  //定义一个node节点
    this.data = data;
    this.left = left;
    this.right = right;
}

function BST() {  //二叉查找树
    this.root = null; //表示二叉树的根节点
    this.insert = insert; //插入节点的方法
    this.inOrder = inOrder;
}

function insert(data) {  //插入节点
    var n = new Node(data, null, null);  //节点对象 用于保存用来保存节点数据 以及当前节点的位置关系
    if (this.root == null) { //判断根节点是否为空,如果是空的话，将此节点放入根节点
        this.root = n;
    } else {
        var nodeNow = this.root;  //现在被判断的节点
        var parent;
        while (true) {
            parent = nodeNow;
            if (data < nodeNow.data) {
                nodeNow = nodeNow.left;
                if (nodeNow == null) {  //nodeNow = 被判断节点的左子节点
                    parent.left = n; // parent = 被判断的节点
                    break;  //跳出整个循环
                }
            } else {
                nodeNow = nodeNow.right;
                if (nodeNow == null) {
                    parent.right = n;
                    break;
                }
            }
        }
    }
}


function inOrder(node) {
    if (node != null) {
        inOrder(node.left);
        inOrder(node.right);
        // console.log(node.data);
    }
}

var nums = new BST();  //实例化二叉查找树
//插入节点
nums.insert(23);
nums.insert(45);
nums.insert(16);
nums.insert(37);
nums.insert(3);
nums.insert(99);
nums.insert(22);
inOrder(nums.root);